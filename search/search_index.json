{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hiss(w) The SolarSoftware (SSW) stack contains nearly every piece of software a solar physicist needs. While libraries like Astropy , SunPy , and ChiantiPy provide Python equivalents to many of these IDL packages, there's still a lot of functionality only available in SSW. hissw ( hiss (like a snake) + SSW) is a ( VERY ) lightweight (~1 file) Python package that allows you to write IDL scripts (either inline or in a separate file) which use your installed SSW packages and return the results to your local Python namespace. hissw uses Jinja2 templates to generate SSW startup scripts and then runs your IDL code using subprocess , i.e. the shell. You can also use Jinja syntax to inject arguments from Python into IDL. The results are then saved to a file and then loaded back in using the amazing readsav() function in scipy.io . Install and Configuration hissw has two dependencies, jinja2 a powerful templating engine scipy standard scientific tools for Python To install hissw and its dependencies, $ pip install hissw You can also install the above dependencies with conda . Alternatively, you can download and install the source yourself, $ git clone https://github.com/wtbarnes/hissw.git $ cd hissw $ python setup.py install Lastly, you can set the locations of your IDL and SSW installs in a configuration file located in $HOME/.hissw/hisswrc , [hissw] ssw_home = /path/to/ssw/tree idl_home = /path/to/local/idl/install Note that if you do not create this file, you will be required to specify it each time you setup a SSW script environment , using the keywords ssw_home and idl_home . If you've downloaded the source, you can run the tests (requires pytest to be installed) to make sure everything is working properly, $ pytest Bridging the IDL-Python Gap the Bad Way... hissw is a hack, albeit a clever one. In general, the methodology employed here (round-tripping everything in memory to disk) is a terrible idea . There's no shared memory between Python and IDL or anything fancy like that. If you're interested in something more complicated (and harder to install), you may want to check out the more official Python-to-IDL bridge . Word(s) of Caution Python-3 only A local install of of IDL and SSW is required Relies on executing shell commands with the subprocess module. I've only tested this on Linux and macOS. Windows users may encounter difficulties. Be careful when injecting large pieces of data into your IDL script as this must be written to a file. It may be better to load it at (IDL) runtime. Widgets and plotting will (likely) not work This has not been tested extensively against all SSW/IDL functionality. There are likely many cases where hissw will not work. Bug reports and pull requests welcome!","title":"Getting Started"},{"location":"#hissw","text":"The SolarSoftware (SSW) stack contains nearly every piece of software a solar physicist needs. While libraries like Astropy , SunPy , and ChiantiPy provide Python equivalents to many of these IDL packages, there's still a lot of functionality only available in SSW. hissw ( hiss (like a snake) + SSW) is a ( VERY ) lightweight (~1 file) Python package that allows you to write IDL scripts (either inline or in a separate file) which use your installed SSW packages and return the results to your local Python namespace. hissw uses Jinja2 templates to generate SSW startup scripts and then runs your IDL code using subprocess , i.e. the shell. You can also use Jinja syntax to inject arguments from Python into IDL. The results are then saved to a file and then loaded back in using the amazing readsav() function in scipy.io .","title":"hiss(w)"},{"location":"#install-and-configuration","text":"hissw has two dependencies, jinja2 a powerful templating engine scipy standard scientific tools for Python To install hissw and its dependencies, $ pip install hissw You can also install the above dependencies with conda . Alternatively, you can download and install the source yourself, $ git clone https://github.com/wtbarnes/hissw.git $ cd hissw $ python setup.py install Lastly, you can set the locations of your IDL and SSW installs in a configuration file located in $HOME/.hissw/hisswrc , [hissw] ssw_home = /path/to/ssw/tree idl_home = /path/to/local/idl/install Note that if you do not create this file, you will be required to specify it each time you setup a SSW script environment , using the keywords ssw_home and idl_home . If you've downloaded the source, you can run the tests (requires pytest to be installed) to make sure everything is working properly, $ pytest","title":"Install and Configuration"},{"location":"#bridging-the-idl-python-gap-the-bad-way","text":"hissw is a hack, albeit a clever one. In general, the methodology employed here (round-tripping everything in memory to disk) is a terrible idea . There's no shared memory between Python and IDL or anything fancy like that. If you're interested in something more complicated (and harder to install), you may want to check out the more official Python-to-IDL bridge .","title":"Bridging the IDL-Python Gap the Bad Way..."},{"location":"#words-of-caution","text":"Python-3 only A local install of of IDL and SSW is required Relies on executing shell commands with the subprocess module. I've only tested this on Linux and macOS. Windows users may encounter difficulties. Be careful when injecting large pieces of data into your IDL script as this must be written to a file. It may be better to load it at (IDL) runtime. Widgets and plotting will (likely) not work This has not been tested extensively against all SSW/IDL functionality. There are likely many cases where hissw will not work. Bug reports and pull requests welcome!","title":"Word(s) of Caution"},{"location":"examples/aia_example/","text":"The temperature response functions of the EUV channels of the Atmospheric Imaging Assembly (AIA) are used to understand the temperature of the plasma observed by the different telescopes on the instrument. While these are difficult to calculate, SSW provides a single simple routine to calculate them. First, import the needed libraries. import numpy as np import matplotlib.pyplot as plt import astropy.units as u import hissw Next, we need to write the IDL code that will calculate the response functions. Because it is a bit long, we'll put it in a separate file, calc_aia_response.pro . Note the Jinja2 syntax (denoted by the {{}} ) we use to inject our Python variables into the script. response = aia_get_response( / {{ flags | join( ',/' ) }}) ; Pull needed elements out of structure logte = response.logte resp94 = response.a94.tresp resp131 = response.a131.tresp resp171 = response.a171.tresp resp193 = response.a193.tresp resp211 = response.a211.tresp resp335 = response.a335.tresp ; Interpolate interp_logte = {{ temperature | to_unit( 'K' ) | log10 | list }} interp_resp94 = interpol (resp94,logte,interp_logte) interp_resp131 = interpol (resp131,logte,interp_logte) interp_resp171 = interpol (resp171,logte,interp_logte) interp_resp193 = interpol (resp193,logte,interp_logte) interp_resp211 = interpol (resp211,logte,interp_logte) interp_resp335 = interpol (resp335,logte,interp_logte) One of the best parts of hissw is that we can setup all of our input arguments in Python. Note that we can specify the temperature with units and then use the builtin filters to convert it to the units expected by the response function in SSW and in log10 format. We also must convert all arrays to lists for IDL to understand them. temperature = np . linspace ( 0.1 , 100 , 1000 ) * u . MK flags = [ 'temp' , 'dn' , 'timedepend_date' , 'evenorm' ] inputs = { 'flags' : flags , 'temperature' : temperature } Now create the SSW script environment and run the script. We need to include the SDO/AIA package ( which you'll need to install with SSW if you haven't already ) so that the appropriate files are added to the IDL path. ssw = hissw . Environment ( ssw_packages = [ 'sdo/aia' ], ssw_paths = [ 'aia' ]) ssw_resp = ssw . run ( '/path/to/calc_aia_response.pro' , args = inputs ) Finally, plot the response functions for all 6 EUV channels, showing the original (dots) and interpolated (line) values, t = 10. ** ssw_resp [ 'logte' ] for i , channel in enumerate ([ 94 , 131 , 171 , 193 , 211 , 335 ]): plt . plot ( t , ssw_resp [ f 'resp { channel } ' ], 'o' , color = f 'C { i } ' , markevery = 3 ) plt . plot ( temperature , ssw_resp [ f 'interp_resp { channel } ' ], '-' , color = f 'C { i } ' , label = f ' { channel } ' ) plt . xlabel ( r '$T$ [K]' ) plt . ylabel ( 'Response' ) plt . xscale ( 'log' ) plt . yscale ( 'log' ) plt . ylim ( 1e-30 , 3e-24 ) plt . legend () plt . show ()","title":"AIA Response Functions"},{"location":"examples/simple_example/","text":"First, let's look at a few plain IDL examples, no SSW needed. In the simplest case, we can return some quantity generated by IDL (no inputs required) and return it to our Python session. This example comes from Coyote's Guide to IDL Programming . import hissw import matplotlib.pyplot as plt script = ''' n = 5 i = REBIN(LINDGEN(n), n, n) j = REBIN(TRANSPOSE(LINDGEN(n)), n, n) mask = (i GE j) ''' ssw = hissw . Environment () results = ssw . run ( script ) plt . imshow ( results [ 'mask' ]) This should generate a plot that looks something like this, But what if we want to input the size of our upper triangular array with Python? We can use Jinja templating syntax in our IDL script and then pass in an argument for n , script = ''' n = {{ n }} i = REBIN(LINDGEN(n), n, n) j = REBIN(TRANSPOSE(LINDGEN(n)), n, n) mask = (i GE j) ''' results = ssw . run ( script , args = { 'n' : 100 }) plt . imshow ( results [ 'mask' ])","title":"Simple Example"}]}